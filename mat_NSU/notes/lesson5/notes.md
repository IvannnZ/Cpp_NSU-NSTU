# Функции [ссылка на урок](https://www.youtube.com/watch?v=hukr8ZqS5Ys)

# Объявление функций

```c++
[Спецификатор] <возвращаемый тип> имя(аргументы){Тело}
```

Спецификатор - const, virtual, static, ...

* Аргументы находятся в самой внешней области видимости функции
* Статические локальные переменные, объявляются при первом выполнении определения, и живут до конца программы

# Передача параметров

при передаче в программу данные копируются  
для избежания можно передать ссылку/указатель  
лучше по указателю  
Плюсы:

* При передаче видим что передаём указатель(ссылку передаётся так же как и переменная)
* Можно передать NULL

Для возврата можно передать указатель, куда положить возвращаемое значение

#### Для возвращение нескольких значений, можно

```c++
tie(a,b) = foo()
[a, b] = foo()
```

При вызове выполняется проверка преобразование типов, в соответствии с семантикой инициализации. Но только один шаг.

Преобразование типа - конструктор принимающий в другой тип

```c++
struct x {}; // Пустой конструктор
struct Y { Y()(} Y(X){} }; // Пустой конструктор, и конструктор от X 
struct Z { Z(){} Z(Y){} }; // Пустой конструктор, и конструктор от Y

void apply(Z){}

int main(){
  apply(Y()); // Сработает, так как нужно ТОЛЬКО ОДНО перебразование
  apply(X()); // Не сработает, нужно 2
}
```
Порядок вычисления аргументов не определен.
```c++
void foo(int a, int& b, int){/*…*/}
foo (++i, arr[i + 1], 0);
```