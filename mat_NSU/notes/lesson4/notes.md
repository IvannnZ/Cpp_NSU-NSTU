# Встроенные типы, инструкции и операторы [ссылка на урок](https://www.youtube.com/watch?v=zCZ-y2XQTW4)

# Типы данных


# Фундаментальные типы
## Всего фундаментальных типов 4

* Логический
* Символьный
* Целый
* Вещественный


ну то что она разные все и так понимают, и по сути типы описывают то как мы можем работать с различными данными.  
по сути есть большие 3 типа: Целые, С плавающей точкой, и Указатели

*  есть различные модификаторы литералов, к примеру 1L - long, 1u - unsigned, 1s - short

### Литералы, предстваление типа при объявлениие 
#### Пример:
0 может быть как и указателем, так и int, short, long ..., но компилятор его всегда интерпретирует к int

# Представление вещественных чисел в компе

* fixed point (до какого-то бита одни целые, после дробная часть)
* floating point (биты делим на 3 части, 1 часть определяет знак(<0 / >0, потом мантиса(man), и экспонента(exp), и в реальности число это (-1)^s * man * (base)^exp)

# Встроенные типы

* Указатели
* Ссылки
* Массивы

# Пользовательские

Даже если они есть в стандартной, они пользовательские, к примеру string(Все те кто не поддерживаются языком)

# Размеры типов

В стандарте не указано какого размера должны быть типы, но есть гарантии, что:
* 1 == char <= short <= int <= long
* 1 <= bool <= long
* char <= wchar_t <= long
* float <= double <= long double
* T == signed T == unsigned T

Единственное есть 2 типа, которые гарантируют свой размер, в 1 машинное слово: **size_t**, **ptrdiff**  

**При написании кода для разных систем это стоит учитывать**  

# Явное приведение типов

* Базовые типы неявно приводятся друг к другу, многие с потерей значимости (warning).

Есть 4 приведения

* static_cast
  * T1 = static_cast<T1>T2
  * Между близкими типами (арифмитическими)
  * **можно из void\* в нужный**
  * может делать преобразования из базового класса в дочерний, если не виртуальный
  * можно когда T1 умеет конструироваться от T2: T2 a = static_cast<T1>T2 == T2 a(T1)
* reinterpret_cast
  * Используется для переосмысления памяти переменной в качестве другого типа данных.
  * можно превращать указатели из 1 типа в другой, но в основном указатели из 1 функции в другую
  * T2* = reinterpret_cast<T2*>(T1)
* const_cast
  * T1 = const_cast<T1>const T2
  * из константы в обычный
* dynamic (между сеткой классов наследования)
  * будет позже

Так же есть запись  

T2 = (T2)T1  
это конструкция сначала будет делать static, потом reinterpret, и в конце const

# Тип void

Применения
* указатель на что-то(мы не знаем куда указываем)
* можно передать в функцию без параметров
* можно создать функцию которая ничего не возвращает

# Строки

Есть string, она хорошая, но ещё есть наследство от Си  
null terminated string  

имеет тип:  
* const char[] str = "Hello"; // нельзя менять (константа), самый правильный с точки зрения плюсов
* char* c_ctyle = "c ctile"; // не стоит менять, может быть не готова к изменениям (сделана для совместимости с си)
* char can_edit[] = "eddit"; // просто массив который можно менять

так же литерал может быть многосточным, тогда в конце строки должно стоять '\':  
"first line"  
"second line\  
third line"

последний символ '/0' - конец строки   

# enum - перечесления (До С++11)

Инструмент для определения набора именованных констант

определение:  
enum <имя_перечисления> { <значение_1>, <значение_2> = 5, <значение_3> ...}  
использование:  
if (<имя_перечисления> == <значение_1>)...  
По умолчанию значения enum от нуля, с шагом в 1
можно определять некоторые константы, и все после будут с шагом в 1

# typedef
Определение:  
typdef std::map<std::string, student> students_t;

* Задаёт синоним имени, не задаёт новый тип
* Делает код короче - проще читать
* Платформанезависимые типы
* "Протаскивает" тип через шаблон
* имеет внутреннюю компановку


# Объявления переменных

Объявление разбивается на 4 части

* Необязательный спецификатор (e.g. extern, virtual)
* Базовый тип: const char
* Объявляющая часть: array[]
  * Идентификатор: буквы, _, цифры(но начало не с цифры)
  * Длина не ограничена стандартом, но ограничена реализацией
* Необязательный инициализатор: = "HELLO, WORLD!"

#### Объявление через запятую - остаётся только базовый тип

int * x, y = 1, *const z = 0;  
int *x; int y = 1; int *const z = 0;


# Области видимости и действия

Область видмости, это всё где мы с ней можем взаимодействовать  
Область действия, это всё где она есть, даже если мы не можем с ней взаимодействовать(перетирание переменной в скоупе/функции)

#### Глобальная переменная
* если в единице трансляции, с момента объявления, и до конца файла
* если в .h, до конца файла где мы подключили этот файли
  * для определения можно делать **inline** переменную

#### обращение к глобальной переменной "::"
Если мы в функцию определяем 2 переменную с именем глобальной, то в этой функции мы имеем дело с локальной переменной, но чтобы обратьиться к глобальной нужно перед именем поставить "::" -> ::<имя переменной>  
Но если мы в скоупе мы объявим 2 переменную, то к ней через "::" обратиться не сможем, это обращение к глобальным переменным

# struct

В плюсах структуры это почти тоже самое что и класс, с различием в том что по умолчанию в структуре поля публичные, а в классе приватные, и структуры по умолчанию наследуются публично, а классы приватно

Размер структуры не обязан быть размером суммы полей  
Это сделано для того чтобы они не попадали на границы машинных слов, **на каждой системе по разному**  

Но можно сделать и без выравнивания

#### объявление

можно объявлять, и не определять, до того момента, когда нам понадобится их размер  

# Операторы(основные)

* Область видимости
  * \[namespace/ class]::name
* Выбор члена
  * object.member
  * ptr->member
* Доступ по индексу
  * pointer[]
* Вызов функции
  * expr(expr-list)
* инкремент/декремент
  * lvalue++ (постфиксный)
  * ++lvalue (префиксный)
  * lvalue-- (постфиксный)
  * --lvalue (префиксный)
* Идентификатор типа
  * typeid({expr| type})
* Преобразование типов
  * static_cast<type>(expr)
  * dynamic_cast<type>(expr)
  * const_cast<type>(expr)
  * * reinterpret_cast<type>(expr)
* Взятие размера
  * sizeof({expr|type})
* Унарные префиксные операторы
  * ~lvalue
* Разыменование
  * *expr
* Выделение/освобождение памяти
  * new type (expr-list)
* Бинарные арифметические операторы
  * expr * expr
* Сдвиги
  * expr << expr
  * expr >> expr
* Бинарные операторы сравнения
  * expr < expr
* Бинарные логические операторы
  * expr || expr
  * expr && expr
* Условное выражение
  * expr ? expr : expr
* Присваивания
  * expr = expr
  * expr <<= expr
  * expr += expr
* Генерация исключения
  * throw expr
* Запятая
  * expr, expr

**Унарные операторы** выполняются **справа на лево**

Пример  

x = a(), b(); - x = a(); b();
x = (a(), b()); - x = b(); a();

# Выражения

* Результат Расширяется в большую сторону (int + short = int)
* Ленивое вычисление && и || если 1 уже гарантирует ответ, то 2 проверяться не будет

# Инкремент/Декремент

* **Префиксный**: изменил, вернул **новое**
* **Постфиксный**: скопировал, изменил, вернул **старое**(копию)

# Инструкция (statement) выбора

* if 
  * Можно сделать перменную внутри if(ptr = p = get_pointer())
  * если только 1 действие, то можно без фигурных скобочек
* switch
  * Обязательно **константа** где **case**
  * окончание ветки: break, return, throw, exit(0) **При вызове 1 кейса выполнится some();, some2();**
  * если ничего не подойдёт выполнится default
#### Пример
```c++
switch(id)  
{  
case 1:  
  some();  
case 2:  П
  some2();
  break;
caseе 3:
  some3();
  break;
default:
  some42();
```
При вызове 1 кейса выполнится some();, some2();

# Циклы

* for(init; cond; modification) {body}
* while(cond){body}
* do {body} while(cond)

### Управление

* Досрочный выход
  * break
  * return
  * throw
  * exit(0)
* Продолжение
  * continue


# Коментарии
* Однострочные - //
* Многострочные - /* */
### БАЗА
* Лучше без коментов, чем не релевантные
* Если сложная логика лучше, пояснение
* Сложный алгоритм - ссылку на статью
* Желательно
  * в заголовке файла, то зачем он, или что в нём написано
  * разметка ///////////////