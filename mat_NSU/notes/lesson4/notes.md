# Встроенные типы, инструкции и операторы [ссылка на урок](https://www.youtube.com/watch?v=zCZ-y2XQTW4)

# Типы данных


# Фундаментальные типы
## Всего фундаментальных типов 4

* Логический
* Символьный
* Целый
* Вещественный


ну то что она разные все и так понимают, и по сути типы описывают то как мы можем работать с различными данными.  
по сути есть большие 3 типа: Целые, С плавающей точкой, и Указатели

*  есть различные модификаторы литералов, к примеру 1L - long, 1u - unsigned, 1s - short

### Литералы, предстваление типа при объявлениие 
#### Пример:
0 может быть как и указателем, так и int, short, long ..., но компилятор его всегда интерпретирует к int

# Представление вещественных чисел в компе

* fixed point (до какого-то бита одни целые, после дробная часть)
* floating point (биты делим на 3 части, 1 часть определяет знак(<0 / >0, потом мантиса(man), и экспонента(exp), и в реальности число это (-1)^s * man * (base)^exp)

# Встроенные типы

* Указатели
* Ссылки
* Массивы

# Пользовательские

Даже если они есть в стандартной, они пользовательские, к примеру string(Все те кто не поддерживаются языком)

# Размеры типов

В стандарте не указано какого размера должны быть типы, но есть гарантии, что:
* 1 == char <= short <= int <= long
* 1 <= bool <= long
* char <= wchar_t <= long
* float <= double <= long double
* T == signed T == unsigned T

Единственное есть 2 типа, которые гарантируют свой размер, в 1 машинное слово: **size_t**, **ptrdiff**  

**При написании кода для разных систем это стоит учитывать**  

# Явное приведение типов

* Базовые типы неявно приводятся друг к другу, многие с потерей значимости (warning).

Есть 4 приведения

* static_cast
  * T1 = static_cast<T1>T2
  * Между близкими типами (арифмитическими)
  * **можно из void\* в нужный**
  * может делать преобразования из базового класса в дочерний, если не виртуальный
  * можно когда T1 умеет конструироваться от T2: T2 a = static_cast<T1>T2 == T2 a(T1)
* reinterpret_cast
  * Используется для переосмысления памяти переменной в качестве другого типа данных.
  * можно превращать указатели из 1 типа в другой, но в основном указатели из 1 функции в другую
  * T2* = reinterpret_cast<T2*>(T1)
* const_cast
  * T1 = const_cast<T1>const T2
  * из константы в обычный
* dynamic (между сеткой классов наследования)
  * будет позже

Так же есть запись  

T2 = (T2)T1  
это конструкция сначала будет делать static, потом reinterpret, и в конце const

# Тип void