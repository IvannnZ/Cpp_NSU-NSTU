# Работа с памятью, выполнение программ [ссылка на урок](https://www.youtube.com/watch?v=TajLTcjBgIg&list=PLlb7e2G7aSpTFea2FYxp7mFfbZW-xavhL&index=3)

## Есть 2 Арихитектуры, 
* гарвардская архитектура(быстрее)
  * команды и память лежать в разных местах
* фон неймана(дешевле)
  * команды и данные это одно и тоже
* есть гибриды, по типу L1 кэш в процессоре

# Процессы и потоки

* Процесс - ресурсы:
  * адресное пространство(память)
  * объекты ядра(файловые дискрипторы, объекты, синхронизации, сокеты)
  * при закрытии процесса, вся память, файлы, порты закрываются
* Поток - выполнение инструкций
  * Последовательность команд
  * стек
  * Thread Local Storage (TLS) (данные этого потока)
  * Общие ресурсы
можно в одну и ту же память обращаться из разных потоков, главное чтобы не было data-race

# Память
* стек
  * быстрое выделение/удаление
  * столько сколько потоков **будет позже**
* heap 
  * можно доступаться из других потоков

# Устройства памяти процесса
* сегмент кода
* сегмент данных
  * глобальные переменные
  * BSS(глобальные переменные без инициализации) **static**
  * heap (может не один) (растёт вверх(обычно))
* Стек (может быть не один) [2-4 мб] (растёт вниз(обычно))
о
# Страничная память
#### По сути виртуальная память. Для нашей пронраммы вся память идёт последовательно, а для железа, они могут быть где угодно
* задачи
  * избежать фрагментацию
  * изоляция процессов
  * страницы только для чтения и неисполняемые
  * свопинг
  * отображение файлов в память
  * разделяемая процессами общая память

# Указатели
* обычная переменная
  * размер - машинное слово
  * Значение - адрес другой переменной

int c = 42;  
int p = &c;  
& - взятие адреса переменной
std::cout<<*p;  
\* - Разыменование(то что лежит по тому адресу)

**нельзя просто приравнять к 5 - это литерал числа, и это ошибка компиляции**


# NULL и nullptr
### NULL
по сути это 0(ноль)  
**\#define NULL 0**
* гарантируется что нет объектов с нулевым адресом  
*используется как указатель, который не ссылается на объект*
### nullptr - с 11 стандарта
сделан для того чтобы точно указывать что это именно указатель, а не 0, который можно интерпретировать как int так и как и пустой указатель


# Массивы
* непрерывная последовательность объектов заданного типа
* индексация [0, n-1]
* Размер - константа, либо динамически через new
  * но в Си c c99 есть VLA (Variable Length Array) по сути мы размер стека делаем в рантайме, и мы можем 
* строки - массивы символов
* если не инициализирую, то мусор, если же инициализирую хоть {}, то инициализация нулями
  * {1, 2, 3, ...} - список инициализации

# Массивы и Указатели
* массив можно испольщовать там же, где и указатель (как значение)
* При передаче в функцию теряется размер
  * передвать и ссылку на начало, и размер(ну или можно указатель на конец массива дать)

# Арифметика указателей

* если складываме указатель, и число, то мы число умножаем на размер одного элемента массива(по сути &arr[2] == arr + 2, незамвисимо от размера, и ещё arr[5] == *(arr + sizeof(arr[0]) * 5))
* не стоит сравнивать/вычитать указатели из разных массивов(UB)
* нельзя складывать указатели
* есть тип данных ptrdiff_t тип данных который хранит указатели, знаковый, если беззнаковый size_t

# константы

* вместо magic numbers
* должна быть проинициализированна при объявлении
* можно сделать масиив
* часто оптимизируетя при компиляции
* можно указывать на константу(указатель на константу, не понял как сделать констаннтный указатель), при чём не важно куда мы указываем, на константу, или на просто число, менять мы его не можем: int a = 5; const int* ptr_a = &a; a = 9;/\*ok\*/ *ptr_a = 9;/\*error\*/ ptr_a = &b; /\*ok\*/
* без оптимизации, конда указываем на константное значение, компилятор не знает где он будет лежать, так же работает с extern

### Константные указатели и указатель на константу
