# Работа с памятью, выполнение программ [ссылка на урок](https://www.youtube.com/watch?v=TajLTcjBgIg&list=PLlb7e2G7aSpTFea2FYxp7mFfbZW-xavhL&index=3)

## Есть 2 Арихитектуры, 
* гарвардская архитектура(быстрее)
  * команды и память лежать в разных местах
* фон неймана(дешевле)
  * команды и данные это одно и тоже
* есть гибриды, по типу L1 кэш в процессоре

# Процессы и потоки

* Процесс - ресурсы:
  * адресное пространство(память)
  * объекты ядра(файловые дискрипторы, объекты, синхронизации, сокеты)
  * при закрытии процесса, вся память, файлы, порты закрываются
* Поток - выполнение инструкций
  * Последовательность команд
  * стек
  * Thread Local Storage (TLS) (данные этого потока)
  * Общие ресурсы
можно в одну и ту же память обращаться из разных потоков, главное чтобы не было data-race

# Память
* стек
  * быстрое выделение/удаление
  * столько сколько потоков **будет позже**
* heap 
  * можно доступаться из других потоков

# Устройства памяти процесса
* сегмент кода
* сегмент данных
  * глобальные переменные
  * BSS(глобальные переменные без инициализации) **static**
  * heap (может не один) (растёт вверх(обычно))
* Стек (может быть не один) [2-4 мб] (растёт вниз(обычно))
о
# Страничная память
#### По сути виртуальная память. Для нашей пронраммы вся память идёт последовательно, а для железа, они могут быть где угодно
* задачи
  * избежать фрагментацию
  * изоляция процессов
  * страницы только для чтения и неисполняемые
  * свопинг
  * отображение файлов в память
  * разделяемая процессами общая память

# Указатели
* обычная переменная
  * размер - машинное слово
  * Значение - адрес другой переменной

int c = 42;  
int p = &c;  
& - взятие адреса переменной
std::cout<<*p;  
\* - Разыменование(то что лежит по тому адресу)

**нельзя просто приравнять к 5 - это литерал числа, и это ошибка компиляции**


# NULL и nullptr
### NULL
по сути это 0(ноль)  
**\#define NULL 0**
* гарантируется что нет объектов с нулевым адресом  
*используется как указатель, который не ссылается на объект*
### nullptr - с 11 стандарта
сделан для того чтобы точно указывать что это именно указатель, а не 0, который можно интерпретировать как int так и как и пустой указатель


# Массивы
* непрерывная последовательность объектов заданного типа
* индексация [0, n-1]
* Размер - константа, либо динамически через new
  * но в Си c c99 есть VLA (Variable Length Array) по сути мы размер стека делаем в рантайме, и мы можем 
* строки - массивы символов
* если не инициализирую, то мусор, если же инициализирую хоть {}, то инициализация нулями
  * {1, 2, 3, ...} - список инициализации

# Массивы и Указатели
* массив можно испольщовать там же, где и указатель (как значение)
* При передаче в функцию теряется размер
  * передвать и ссылку на начало, и размер(ну или можно указатель на конец массива дать)

# Арифметика указателей

* если складываме указатель, и число, то мы число умножаем на размер одного элемента массива(по сути &arr[2] == arr + 2, незамвисимо от размера, и ещё arr[5] == *(arr + sizeof(arr[0]) * 5))
* не стоит сравнивать/вычитать указатели из разных массивов(UB)
* нельзя складывать указатели
* есть тип данных ptrdiff_t тип данных который хранит указатели, знаковый, если беззнаковый size_t

# константы

* вместо magic numbers
* должна быть проинициализированна при объявлении
* можно сделать масиив
* часто оптимизируетя при компиляции
* можно указывать на константу(указатель на константу, не понял как сделать констаннтный указатель), при чём не важно куда мы указываем, на константу, или на просто число, менять мы его не можем: int a = 5; const int* ptr_a = &a; a = 9;/\*ok\*/ *ptr_a = 9;/\*error\*/ ptr_a = &b; /\*ok\*/
* без оптимизации, конда указываем на константное значение, компилятор не знает где он будет лежать, так же работает с extern

### Константные указатели и указатель на константу

* Константный указатель
type * const name = ptr;
  * можно менять на что указывает
  * нельзя менять куда указывает
* Указатель на константу  
const type * name = ptr;  
type const * name = ptr;  
  * нельзя менять на что указывает
  * можно менять куда указывает

* Константный указатель на константу
  const type *const name = ptr;
  type const * const name = ptr;
  * нельзя менять на что указывает
  * нельзя менять куда указывает

# Ссылки

* задаёт псевдоним переменной, обязана быть инициализирована
* Нельзя выполнять операции над ссылками
* Можно думать как о константном указателе, который всегда разыменован
* можно сделать ссылку на указатель, но не указатель на ссылку

фактически 2 имя


Объявление:  
type& name

int x = 5;  
int &y = x;  
y++; // x == 6  
int * p = &y; // p == &x;

int const& z = x; // z - константная версия x;

* можно передать в функции, и не думать об разименовании (но не всегда стоит так делать)

## Инициализация константных ссылок
* Для обычных ссылок должен быть lvalue (переменная, не 5(rvalue)) объект
* Для константной - не обязан (T const &)
* для константных можно и просто число rvalue (для них может создаться специальный объект)

# Выделение памяти

* Выделение/освобождение памяти в heap: (new/delete)
* при нехватки памяти генерируется исключение std::bad_alloc

#### Пример:
try  
{
int* p = new int (42); // один объект  
int* arr = new int [52]; //массив длины 52  
delete p; // не путать выделение и освобождение с [] или без( это из-за разных префиксов у массивов, и просто еденичных элеменьтов(в какждой ОС по своему))  
delete [] arr;  
}  
catch(std::bad_alloc const&)  


### Placement new
### Так же можно не просто выделить память, а к примеру переопределить некоторую память на новый тип данных:
#### Пример

void* p = …;  
T* pt = new (p) T(…);  
pt->~T();  №Т

Может быть полезно при написании кода безопасного на исключения, можно вызвать явный деструктор  
*К примеру в функции выделилась память, она выкинула исключение, и если не это переопределение нашей памяти, то мы бы не смогли её после освободить, так как больше бы не имели к ней доступ*

### Так же можно переопределить операторы выделения памяти
#### Пример

void* operator new (size_t );  
void operator delete(void* p);  
void* operator new [] (size_t );  
void operator delete[] (void *p);  

# RAII или же умные указатели (будет позже)
#### Resource Acquisition Is Initialisation

* Эта идиома удобна для объектов владеющих ресурсами

# Утечки памяти (memory leaks)*

* в линуксе valgrind